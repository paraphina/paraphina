#!/usr/bin/env python3
from __future__ import annotations

from pathlib import Path
import re

ROOT = Path(__file__).resolve().parents[1]
CARGO_TOML = ROOT / "paraphina" / "Cargo.toml"
CONNECTOR_DIR = ROOT / "paraphina" / "src" / "live" / "connectors"


def render_table(rows, headers):
    col_widths = [len(h) for h in headers]
    for row in rows:
        for idx, key in enumerate(headers):
            col_widths[idx] = max(col_widths[idx], len(row.get(key, "")))

    def fmt_row(row):
        return "| " + " | ".join(
            row.get(h, "").ljust(col_widths[i]) for i, h in enumerate(headers)
        ) + " |"

    header_line = fmt_row({h: h for h in headers})
    sep_line = "| " + " | ".join("-" * w for w in col_widths) + " |"
    body = "\n".join(fmt_row(r) for r in rows)
    return "\n".join([header_line, sep_line, body])


def parse_features(path: Path) -> set[str]:
    if not path.exists():
        return set()
    lines = path.read_text(encoding="utf-8").splitlines()
    in_features = False
    features = set()
    for raw in lines:
        line = raw.split("#", 1)[0].strip()
        if not line:
            continue
        if line.startswith("[") and line.endswith("]"):
            in_features = line == "[features]"
            continue
        if not in_features:
            continue
        if "=" not in line:
            continue
        key = line.split("=", 1)[0].strip()
        if key:
            features.add(key)
    return features


def parse_connector_caps(path: Path) -> dict[str, bool] | None:
    if not path.exists():
        return None
    text = path.read_text(encoding="utf-8")
    def find_bool(name: str) -> bool | None:
        match = re.search(rf"{name}\s*:\s*bool\s*=\s*(true|false)", text)
        if not match:
            return None
        return match.group(1) == "true"

    stub = find_bool("STUB_CONNECTOR")
    market = find_bool("SUPPORTS_MARKET")
    account = find_bool("SUPPORTS_ACCOUNT")
    execution = find_bool("SUPPORTS_EXECUTION")
    if stub is None and market is None and account is None and execution is None:
        return None
    return {
        "stub": bool(stub),
        "market": bool(market),
        "account": bool(account),
        "execution": bool(execution),
    }


def support_level(feature_present: bool, caps: dict[str, bool] | None) -> str:
    if not feature_present:
        return "MissingFeature"
    if caps is None:
        return "Stub"
    if caps.get("stub"):
        return "Stub"
    if caps.get("market") and caps.get("account") and caps.get("execution"):
        return "Market+Account+Exec"
    if caps.get("market") and caps.get("account"):
        return "Market+Account"
    if caps.get("market"):
        return "MarketOnly"
    return "Stub"


def yes_no(value: bool, detail: str = "") -> str:
    return "Yes" + (f" ({detail})" if detail else "") if value else "No"


def main():
    features = parse_features(CARGO_TOML)
    headers = [
        "Connector",
        "Venue",
        "Feature flags",
        "Support",
        "Market data",
        "Account",
        "Execution",
        "Cancel all",
        "Trade modes",
        "Multi-connector",
        "CLI/env selection",
        "Notes",
    ]
    specs = [
        {
            "name": "mock",
            "venue": "Mock",
            "feature": None,
            "module": None,
            "market": True,
            "account": False,
            "execution": False,
            "support_override": "MarketOnly",
            "market_detail": "synthetic L2 snapshots",
            "account_detail": "",
            "exec_detail": "ShadowAckAdapter only",
            "cancel_all": "No",
            "trade_modes": "Shadow, Paper",
            "cli": "--connector mock | PARAPHINA_LIVE_CONNECTOR=mock",
            "notes": "Market data generated by live binary; no account/REST wiring.",
        },
        {
            "name": "hyperliquid",
            "venue": "Hyperliquid",
            "feature": "live_hyperliquid",
            "module": CONNECTOR_DIR / "hyperliquid.rs",
            "market_detail": "public WS",
            "account_detail": "polling + private WS when enabled",
            "exec_detail": "REST place/cancel",
            "cancel_all": "Yes",
            "trade_modes": "Shadow, Paper, Testnet, Live",
            "cli": "--connector hyperliquid | PARAPHINA_LIVE_CONNECTOR=hyperliquid",
            "notes": "Account needs HL_VAULT_ADDRESS; private WS needs HL_PRIVATE_KEY.",
        },
        {
            "name": "hyperliquid_fixture",
            "venue": "Hyperliquid (fixture)",
            "feature": "live_hyperliquid",
            "module": CONNECTOR_DIR / "hyperliquid.rs",
            "market": True,
            "account": True,
            "execution": False,
            "support_override": "Market+Account",
            "market_detail": "fixture feed",
            "account_detail": "account fixture feed",
            "exec_detail": "exec client not wired",
            "cancel_all": "No",
            "trade_modes": "Shadow, Paper",
            "cli": "--connector hyperliquid_fixture | PARAPHINA_LIVE_CONNECTOR=hyperliquid_fixture",
            "notes": "Offline replay only; uses HL_FIXTURE_DIR.",
        },
        {
            "name": "lighter",
            "venue": "Lighter",
            "feature": "live_lighter",
            "module": CONNECTOR_DIR / "lighter.rs",
            "market_detail": "public WS",
            "account_detail": "polling only when non-shadow + not paper",
            "exec_detail": "REST; paper mode suppresses sending",
            "cancel_all": "Yes",
            "trade_modes": "Shadow, Paper, Testnet, Live",
            "cli": "--connector lighter | PARAPHINA_LIVE_CONNECTOR=lighter",
            "notes": "Private WS exists but not wired by live binary.",
        },
        {
            "name": "extended",
            "venue": "Extended",
            "feature": "live_extended",
            "module": CONNECTOR_DIR / "extended.rs",
            "market_detail": "public WS (+ REST snapshot)",
            "account_detail": "REST account snapshot (signed)",
            "exec_detail": "REST place/cancel + cancel-all",
            "cancel_all": "Yes",
            "trade_modes": "Shadow, Paper, Testnet, Live",
            "cli": "--connector extended | PARAPHINA_LIVE_CONNECTOR=extended",
            "notes": "Roadmap-B venue; signed REST account/execution with strict live gating.",
        },
        {
            "name": "aster",
            "venue": "Aster",
            "feature": "live_aster",
            "module": CONNECTOR_DIR / "aster.rs",
            "market_detail": "public WS (+ REST snapshot)",
            "account_detail": "REST account snapshot (signed)",
            "exec_detail": "REST place/cancel + cancel-all",
            "cancel_all": "Yes",
            "trade_modes": "Shadow, Paper, Testnet, Live",
            "cli": "--connector aster | PARAPHINA_LIVE_CONNECTOR=aster",
            "notes": "Roadmap-B venue; signed REST account/execution with strict live gating.",
        },
        {
            "name": "paradex",
            "venue": "Paradex",
            "feature": "live_paradex",
            "module": CONNECTOR_DIR / "paradex.rs",
            "market_detail": "public WS",
            "account_detail": "REST account snapshot (JWT)",
            "exec_detail": "REST place/cancel + cancel-all",
            "cancel_all": "Yes",
            "trade_modes": "Shadow, Paper, Testnet, Live",
            "cli": "--connector paradex | PARAPHINA_LIVE_CONNECTOR=paradex",
            "notes": "Roadmap-B venue; JWT auth + signed payloads with strict live gating.",
        },
    ]
    rows = []
    for spec in specs:
        feature = spec["feature"]
        feature_present = True if feature is None else feature in features
        caps = parse_connector_caps(spec["module"]) if spec["module"] else None
        support = spec.get("support_override") or support_level(feature_present, caps)
        market = spec.get("market", caps.get("market") if caps else False)
        account = spec.get("account", caps.get("account") if caps else False)
        execution = spec.get("execution", caps.get("execution") if caps else False)
        if feature is not None and not feature_present:
            market = False
            account = False
            execution = False
        feature_label = "none" if feature is None else feature
        if feature is not None and not feature_present:
            feature_label = f"{feature} (missing)"
        rows.append(
            {
                "Connector": spec["name"],
                "Venue": spec["venue"],
                "Feature flags": feature_label,
                "Support": support,
                "Market data": yes_no(market, spec["market_detail"] if market else ""),
                "Account": yes_no(account, spec["account_detail"] if account else ""),
                "Execution": yes_no(execution, spec["exec_detail"] if execution else ""),
                "Cancel all": spec["cancel_all"],
                "Trade modes": spec["trade_modes"],
                "Multi-connector": "Yes (multi-connector supported)",
                "CLI/env selection": spec["cli"],
                "Notes": spec["notes"],
            }
        )
    print(render_table(rows, headers))


if __name__ == "__main__":
    main()
