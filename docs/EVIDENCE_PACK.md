# Evidence Pack v1 Specification

## Purpose

The Evidence Pack defines an **audit boundary** for simulation outputs, providing:

1. **Provenance** — tracing outputs back to source code, configuration, and environment
2. **Integrity** — cryptographic hashes for all artifacts enabling verification

This specification establishes a reproducible, machine-verifiable bundle that accompanies every simulation evaluation run.

Evidence packs are generated by:
- `sim_eval suite` — CI suite runner for scenario evaluation (nested evidence packs)
- `sim_eval write-evidence-pack <ROOT>` — Generate evidence pack for any directory (root evidence packs)
- `monte_carlo` — Monte Carlo simulation harness (Step 7.1)
- Phase A Python scripts — Automatically generate root evidence packs after batch runs

---

## Root Evidence Packs vs Nested Suite Evidence Packs

There are two types of evidence packs in the Paraphina system:

### 1. Nested Suite Evidence Packs

Generated by `sim_eval suite` for each suite run. These contain:
- `evidence_pack/suite.yaml` — Copy of the input suite configuration
- `evidence_pack/manifest.json` — Structured metadata with artifact hashes
- `evidence_pack/SHA256SUMS` — Checksums for verification

Nested suite packs are located under each scenario output directory within a suite run.

### 2. Root Evidence Packs

Generated by `sim_eval write-evidence-pack <ROOT>` for any output directory. These provide a top-level seal for Python batch runs that produce multiple outputs (e.g., Phase A promotion pipeline, adversarial search).

Root evidence packs:
- Automatically discover all files under the root directory
- Exclude common junk directories: `evidence_pack/`, `.git/`, `target/`, `__pycache__/`, `.pytest_cache/`
- Generate deterministic SHA256SUMS (sorted by path, atomic write)
- Are fully compatible with verification commands

```bash
# Generate a root evidence pack
sim_eval write-evidence-pack runs/phaseA_study_001

# Verify the root pack
sim_eval verify-evidence-pack runs/phaseA_study_001

# Verify all packs in tree (root + nested)
sim_eval verify-evidence-tree runs/phaseA_study_001
```

Phase A Python scripts automatically call `write-evidence-pack` after completing their runs, ensuring all batch outputs are cryptographically sealed.

---

## Directory Layout

### Suite Output Root vs Evidence Pack Directory

When running `sim_eval suite`, the **suite output root** is the top-level directory containing all suite artifacts. The **evidence pack directory** is a subdirectory within it:

- **Suite Output Root**: The base directory containing all suite run outputs
  - If `--output-dir` is specified: exactly that path
  - If not specified: `runs/suites/<suite_id>/<timestamp>/`
- **Evidence Pack Directory**: Always `<suite_output_root>/evidence_pack/`

### Directory Structure

All evidence pack files reside under `<output_root>/evidence_pack/`:

```
<output_root>/                    # Suite Output Root
├── evidence_pack/                # Evidence Pack Directory
│   ├── manifest.json             # Structured metadata + artifact listing
│   ├── suite.yaml                # Copy of input suite configuration
│   └── SHA256SUMS                # Checksums for verification
├── <scenario_1>/                 # Per-scenario outputs
│   ├── run_summary.json
│   ├── config_resolved.json
│   ├── build_info.json
│   └── evidence_pack/            # Per-scenario evidence pack
│       ├── manifest.json
│       ├── suite.yaml
│       └── SHA256SUMS
└── <scenario_N>/
    └── ...
```

---

## Determinism Requirements

### Relative Paths Only

- All paths in `manifest.json` MUST be relative to `<output_root>`.
- Absolute paths are forbidden; they break portability and reproducibility.

### Stable Ordering

- All lists in `manifest.json` (e.g., `artifacts`) MUST be sorted by `path` (lexicographic, ascending).
- This ensures byte-identical manifests across runs with identical inputs.

### Atomic Writes

- All evidence pack files MUST be written atomically (temp file + rename).
- This prevents partial/corrupt files if a run is interrupted.

---

## manifest.json Specification

### Required Fields

All keys are required. Values may be `null` when best-effort retrieval fails.

```json
{
  "evidence_pack_schema_version": "v1",
  "generated_at_unix_ms": 1703260800000,
  "paraphina_version": "0.1.0",
  "repository": {
    "git_commit": "a1b2c3d4e5f6...",
    "cargo_lock_sha256": "sha256:...",
    "sim_output_schema_sha256": "sha256:..."
  },
  "suite": {
    "source_path": "suites/stress_test.yaml",
    "copied_to": "evidence_pack/suite.yaml",
    "sha256": "sha256:..."
  },
  "artifacts": [
    { "path": "evidence_pack/suite.yaml", "sha256": "sha256:..." },
    { "path": "results/run_001.json", "sha256": "sha256:..." },
    { "path": "results/run_002.json", "sha256": "sha256:..." }
  ]
}
```

### Field Definitions

| Field | Type | Description |
|-------|------|-------------|
| `evidence_pack_schema_version` | string | Always `"v1"` for this spec |
| `generated_at_unix_ms` | integer | Unix timestamp (milliseconds) when pack was generated |
| `paraphina_version` | string | Paraphina version from `Cargo.toml` |
| `repository.git_commit` | string\|null | Git commit SHA (null if not in git repo or dirty) |
| `repository.cargo_lock_sha256` | string\|null | SHA256 of `Cargo.lock` (null if missing) |
| `repository.sim_output_schema_sha256` | string\|null | SHA256 of sim output schema definition (null if N/A) |
| `suite.source_path` | string | Original path to suite YAML (relative to repo root) |
| `suite.copied_to` | string | Always `"evidence_pack/suite.yaml"` |
| `suite.sha256` | string | SHA256 of the suite file |
| `artifacts` | array | List of `{ path, sha256 }` objects for all output files |

### Artifacts Array

- Each entry is `{ "path": "<relative_path>", "sha256": "<hash>" }`.
- Paths are relative to `<output_root>`.
- Sorted lexicographically by `path`.
- **MUST NOT include `evidence_pack/manifest.json`** (self-referential hash is undefined).

---

## SHA256SUMS Contract

The `evidence_pack/SHA256SUMS` file enables standard verification via `sha256sum -c`.

### Contents

The file contains SHA256 lines for:

1. `evidence_pack/manifest.json`
2. `evidence_pack/suite.yaml`
3. Each `artifacts[].path` from the manifest

### Format

Standard `sha256sum` output format:

```
<hash>  evidence_pack/manifest.json
<hash>  evidence_pack/suite.yaml
<hash>  results/run_001.json
<hash>  results/run_002.json
```

### Verification

From `<output_root>`, verify all checksums with:

```bash
(cd <output_root> && sha256sum -c evidence_pack/SHA256SUMS)
```

All lines should report `OK`. Any mismatch indicates tampering or corruption.

---

## Writing Evidence Packs (CLI)

### Generating a root evidence pack

Use `sim_eval write-evidence-pack` to generate an evidence pack for any directory:

```bash
# Generate evidence pack for a Phase A study
sim_eval write-evidence-pack runs/phaseA_study_001

# Output:
# OK: wrote evidence pack for runs/phaseA_study_001 (47 files hashed)
```

This command:
1. Scans all files under the root directory
2. Excludes: `evidence_pack/`, `.git/`, `target/`, `__pycache__/`, `.pytest_cache/`
3. Computes SHA256 hashes for each file
4. Writes `<ROOT>/evidence_pack/SHA256SUMS` (deterministic, sorted by path)
5. Writes `<ROOT>/evidence_pack/manifest.json` (structured metadata)
6. Writes `<ROOT>/evidence_pack/suite.yaml` (for verifier compatibility)

All writes are atomic (temp file + rename) to prevent partial packs.

---

## Offline Verification (CLI)

For strict verification of evidence packs, use the `sim_eval` CLI verifier. This validates manifest schema, all checksums, and directory structure.

### Verifying an entire suite (evidence tree)

Recursively find and verify all evidence packs under a suite output root:

```bash
# Verify all packs in a suite run
sim_eval verify-evidence-tree runs/suites/ci_smoke_v1/20251225_143052

# Or if you used --output-dir
sim_eval verify-evidence-tree /path/to/custom/output
```

**Important**: Pass the **suite output root**, not the evidence_pack directory. If you accidentally pass `<path>/evidence_pack`, the verifier will detect this and provide a helpful error message.

### Verifying a single evidence pack

Verify just the root evidence pack at the suite output root:

```bash
# Verify single pack
sim_eval verify-evidence-pack runs/suites/ci_smoke_v1/20251225_143052
```

### Which command to use?

| Goal | Command |
|------|---------|
| Verify **all** packs in a suite (root + per-scenario) | `verify-evidence-tree <suite_output_root>` |
| Verify **only** the root-level pack | `verify-evidence-pack <suite_output_root>` |

### After running a suite

After `sim_eval suite` completes, it prints the exact commands needed:

```
Output written to: runs/suites/ci_smoke_v1/20251225_143052/
Evidence Pack written to: runs/suites/ci_smoke_v1/20251225_143052/evidence_pack/

To verify all packs:      sim_eval verify-evidence-tree runs/suites/ci_smoke_v1/20251225_143052
To verify the root pack:  sim_eval verify-evidence-pack runs/suites/ci_smoke_v1/20251225_143052
```

### What the verifier checks

- Manifest schema version and required fields
- All artifact checksums match SHA256SUMS
- Directory structure is valid
- No missing or extra files

### Exit codes

- `0`: All checks passed
- `2`: Usage error (missing or extra arguments)
- `3`: Verification failed (integrity or schema mismatch)

### Common Error: Passing evidence_pack directory

If you accidentally pass an evidence_pack directory:

```bash
# WRONG - passes the evidence_pack directory itself
sim_eval verify-evidence-tree runs/suites/my_suite/20251225_143052/evidence_pack
```

The verifier will detect this and print:

```
ERROR: You passed an evidence_pack directory.

The path 'runs/suites/my_suite/20251225_143052/evidence_pack' appears to be an evidence_pack directory
(it contains SHA256SUMS at the root level).

To verify this evidence pack, use one of:
  sim_eval verify-evidence-pack runs/suites/my_suite/20251225_143052
  sim_eval verify-evidence-tree runs/suites/my_suite/20251225_143052
```

### Note

The CLI verifier is additive and complements `sha256sum -c` checks. Both verification methods remain supported.

---

## Monte Carlo Harness (Step 7.1)

The `monte_carlo` binary generates Evidence Pack v1 artifacts as part of its output. This enables audit-grade tracking for Monte Carlo simulation runs.

### Running Monte Carlo with Evidence Pack

```bash
# Run Monte Carlo with default output directory (runs/demo_step_7_1/)
cargo run -p paraphina --bin monte_carlo

# Run with custom output directory
cargo run -p paraphina --bin monte_carlo -- --output-dir runs/my_experiment
```

### Monte Carlo Output Structure

```
<output_dir>/
├── mc_summary.json        # Per-run statistics and aggregate summary
├── mc_runs.csv            # CSV of per-run metrics (if --csv specified)
├── monte_carlo.yaml       # Configuration used for this run
└── evidence_pack/
    ├── manifest.json      # Structured metadata + artifact listing
    ├── suite.yaml         # Copy of monte_carlo.yaml
    └── SHA256SUMS         # Checksums for verification
```

### Verifying Monte Carlo Output

After running Monte Carlo, verify the evidence pack:

```bash
# Verify single evidence pack
cargo run -p paraphina --bin sim_eval -- verify-evidence-pack runs/demo_step_7_1

# Verify all evidence packs under runs/
cargo run -p paraphina --bin sim_eval -- verify-evidence-tree runs
```

Both commands should exit with code `0` for a valid evidence pack.

---

## Related Implementation Notes

### Hedge Engine (Milestone F)

The hedge allocator (`paraphina/src/hedge.rs`) implements production-grade venue constraints:

- **Per-venue margin constraints**: Enforced only when the hedge would increase absolute exposure. Uses `increases_abs_exposure()`, `compute_abs_limit_after_trade()`, and `cap_dq_by_abs_limit()` helper functions.
- **Multi-chunk allocation**: Generates internal chunk candidates per venue, then aggregates into a single order per venue. Deterministic tie-breaking: `(unit_cost ASC, venue_id ASC, chunk_index ASC)`.
- **Convexity spreading**: Optional `chunk_convexity_cost_bps` adds cost per subsequent chunk to spread flow across venues.

Tests in `paraphina/tests/hedge_allocator_tests.rs` cover:
- `hedge_respects_margin_available_cap`: Margin constraint enforcement
- `hedge_margin_cap_limits_new_position_opening`: Opening positions respect margin
- `hedge_multi_chunk_allocation_is_deterministic_and_aggregated`: Multi-chunk determinism
- `hedge_convexity_spreads_flow`: Convexity spreads allocation

---

## Non-Goals (Explicit)

The following are explicitly **out of scope** for Evidence Pack v1:

### No Signing/Attestation

- Cryptographic signatures (GPG, Sigstore, etc.) are reserved for a future version.
- V1 provides integrity (hashes) but not non-repudiation (signatures).

### No Full Environment Capture

- System dependencies, OS version, CPU architecture, etc. are not captured.
- Full reproducibility requires additional tooling (e.g., Nix, Docker image hashes).
- Reserved for future versions.

---

## Implementation Notes

### Generation Workflow

1. Run simulation suite, collecting output artifacts.
2. Copy suite YAML to `evidence_pack/suite.yaml`.
3. Compute SHA256 for all artifacts.
4. Build `manifest.json` with sorted artifacts list.
5. Write `manifest.json` atomically.
6. Generate `SHA256SUMS` including `manifest.json`.
7. Write `SHA256SUMS` atomically.

### Error Handling

- If `git_commit` cannot be determined (dirty tree, not a repo), set to `null`.
- If `Cargo.lock` is missing, set `cargo_lock_sha256` to `null`.
- Missing optional metadata should not fail pack generation.

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v1 | 2024-12 | Initial specification |
